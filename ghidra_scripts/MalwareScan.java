/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//Scan for Malware/C2 Indicators
//@category AI

import ghidra.app.script.GhidraScript;
import ghidra.program.model.listing.Data;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionIterator;
import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.program.model.symbol.Symbol;
import ghidra.program.model.symbol.SymbolIterator;
import ghidra.program.model.listing.Instruction;
import ghidra.program.model.listing.InstructionIterator;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.Arrays;
import ghidra.program.model.listing.DataIterator;
import java.io.FileWriter;


public class MalwareScan extends GhidraScript {

    private static final Set<String> SUSPICIOUS_STRINGS = new HashSet<>(Arrays.asList(
        "cmd.exe", "powershell", "GetProcAddress", "LoadLibrary", 
        "VirtualAlloc", "WriteProcessMemory", "CreateRemoteThread",
        "Mozilla/5.0", "WinINet", "http://", "https://", 
        "/admin", "/login", ".php", ".jsp", "eval(", "exec(",
        "\\\\pipe\\\\", "SeDebugPrivilege"
    ));

    private static final Set<String> HIGH_RISK_IMPORTS = new HashSet<>(Arrays.asList(
        "VirtualAlloc", "VirtualAllocEx", "WriteProcessMemory", "CreateRemoteThread",
        "SetWindowsHookEx", "QueueUserAPC", "RtlMoveMemory",
        "InternetOpen", "HttpSendRequest", "URLDownloadToFile", "socket", "connect", "recv", "send",
        "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "OutputDebugString",
        "RegCreateKey", "RegSetValue", "ShellExecute"
    ));

    private static final Set<String> SUSPICIOUS_OPS = new HashSet<>(Arrays.asList(
        "CALL", "JMP", "RET", "PUSH", "POP", "MOV", "XOR", "ADD", "SUB", "AND", "OR", "TEST", "CMP"
    ));

    @Override
    public void run() throws Exception {
        String[] args = getScriptArgs();
        if (args.length < 1) {
             println("Usage: MalwareScan <output_file>");
             return;
        }
        String outputPath = args[0];
        
        Map<String, Object> findings = new HashMap<>();

        // 1. Scan Imports
        List<String> suspiciousImports = new ArrayList<>();
        SymbolIterator references = currentProgram.getSymbolTable().getExternalSymbols();
        while (references.hasNext()) {
            Symbol sym = references.next();
            String name = sym.getName();
            // Check substrings too (e.g. InternetOpenA vs InternetOpenW)
            for (String risk : HIGH_RISK_IMPORTS) {
                if (name.contains(risk)) {
                    suspiciousImports.add(name);
                    break;
                }
            }
        }
        findings.put("imports", suspiciousImports);

        // 2. Scan Strings
        List<Map<String, String>> suspiciousStrings = new ArrayList<>();
        DataIterator dataIt = currentProgram.getListing().getDefinedData(true);
        while (dataIt.hasNext()) {
            Data d = dataIt.next();
            if (d.hasStringValue()) {
                String strVal = d.getDefaultValueRepresentation().replace("\"", "");
                for (String susp : SUSPICIOUS_STRINGS) {
                    if (strVal.toLowerCase().contains(susp.toLowerCase())) {
                        Map<String, String> sMap = new HashMap<>();
                        sMap.put("address", d.getAddress().toString());
                        sMap.put("value", strVal);
                        suspiciousStrings.add(sMap);
                        break;
                    }
                }
            }
        }
        findings.put("strings", suspiciousStrings);

        // 3. Scan Functions for suspicious patterns
        DecompInterface ifc = new DecompInterface();
        ifc.openProgram(currentProgram);

        FunctionIterator functions = currentProgram.getFunctionManager().getFunctions(true);
        List<Map<String, Object>> suspiciousFunctions = new ArrayList<>();

        monitor.setMessage("Scanning for Malware Patterns...");
        int count = 0;
        
        while (functions.hasNext() && !monitor.isCancelled()) {
            Function func = functions.next();
            // Basic filtering
            if (func.getBody().getNumAddresses() < 20) continue; 

            int score = 0;
            List<String> funcFindings = new ArrayList<>(); // Renamed to avoid conflict with 'findings' map
            
            // Check instructions
            InstructionIterator instructions = currentProgram.getListing().getInstructions(func.getBody(), true);
            while (instructions.hasNext()) {
                Instruction instr = instructions.next();
                String mnemonic = instr.getMnemonicString().toUpperCase();
                
                if (SUSPICIOUS_OPS.contains(mnemonic)) {
                     score++;
                     funcFindings.add("Opcode: " + mnemonic);
                }
            }
            
            // Check symbol imports (if any called from this function - naive check)
            // Ideally we check call references
            
            if (score > 2) {
                DecompileResults res = ifc.decompileFunction(func, 30, monitor);
                if (res != null && res.decompileCompleted()) {
                    String code = res.getDecompiledFunction().getC();
                    // Simple string search in code
                    if (code.contains("WSAStartup") || code.contains("connect") || code.contains("OpenProcess")) {
                        score += 5;
                        funcFindings.add("Network/Process API usage");
                    }
                    
                    Map<String, Object> data = new HashMap<>();
                    data.put("name", func.getName());
                    data.put("address", func.getEntryPoint().toString());
                    data.put("score", score);
                    data.put("findings", funcFindings);
                    data.put("code", code);
                    suspiciousFunctions.add(data);
                }
            }
            
            count++;
            if (count % 50 == 0) {
                monitor.setMessage("Scanned " + count + " functions...");
            }
        }

        // Sort by score
        suspiciousFunctions.sort((a, b) -> Integer.compare((int)b.get("score"), (int)a.get("score")));
        List<Map<String, Object>> topResults = suspiciousFunctions.subList(0, Math.min(suspiciousFunctions.size(), 10));
        findings.put("suspicious_functions", topResults);

        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (java.io.FileWriter writer = new java.io.FileWriter(outputPath)) {
            gson.toJson(findings, writer); // Write the combined findings map
        }
        println("JSON written to " + outputPath);
    }
}
